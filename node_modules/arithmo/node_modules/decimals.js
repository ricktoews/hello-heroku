function Decimals(denom) {
    var base = 10;
    denom = 1*denom;

    var num1 = 1;
    var num2 = denom - 1;

    var decimalData = [];
    for (var i = num1; i <= num2; i++) {
        decimalData.push(new Decimal(i, denom, base));
    }

	return decimalData;
}


function Decimal(num, denom, base) {
    var primes = [
        -1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97
    ];


    var that = this;
    gcf = get_gcf(num, denom);  // GCF of numerator and denominator, for ensuring a reduced fraction.
    var reduced_num = num / gcf;
    var reduced_denom = denom / gcf;
    var base = base;
	this.fraction = { num: num, denom: denom };
    if (reduced_denom < denom) {
		this.reduced = { num: reduced_num, denom: reduced_denom };
    }

    // calc_decimal sets three additional properties:  decimal_length, repeating, and decimal.
    this.decimal_data = calc_decimal();

    function calc_decimal() {
        var section_list = ['', '', ''];
        var section_ndx = 0;
        var palindromic;

        // Call the count_non_repeating method to determine the number of non-repeating digits in the decimal expansion.
        // If the fraction resolves (i.e., has no repeating portion), the count_non_repeating method returns -1.
        var non_repeating = count_non_repeating();
        // If a decimal expansion repeats, non_repeating_tally is used to detect the position at which the repetition begins.
        // If there is no repetition, non_repeating_tally is set to one less than the denominator, which is a position at or beyond the decimal expansion's maximum possible length.
        // Examples:  1/3 = .33333...  The whole thing repeats, so non_repeating_tally is 0.
        //            1/4 = .25  The fraction resolves.  non_repeating_tally is one 3.
        //            1/6 = .1666...  Only the 6's repeat, so non_repeating_tally is 1.
        var non_repeating_tally = non_repeating == -1 ? reduced_denom - 1 : non_repeating;
        // The remainder_flag array contains one element for every possible remainder of a division involving the denominator.  This means the number of elements is one less than the denominator.
        var remainder_flag_list = [];
        for (var i = 1; i < reduced_denom - 1; i++) {
            remainder_flag_list[i] = false;
        } 
        var repeating_decimal_flag = non_repeating != -1;
        var start_repeat = 0;
        var step_digit = 0;
        var step_remainder = reduced_num;
        var decimal_length = 0;
        var linelength = 54;
        // ----- END INITIALIZATION -----

        // ----- BEGIN LONG DIVISION -----
        // Continue the process as long as both of two conditions are true:
        //   a) there is a remainder,
        //   b) the current remainder (step_remainder) has not yet been encountered.
        while (step_remainder != 0 && !remainder_flag_list[step_remainder]) {
            remainder_flag_list[step_remainder] = true;
            step_digit = Math.floor(step_remainder * base / reduced_denom);
            // Check for the end of the non-repeating portion of the decimal.
            if (decimal_length == non_repeating_tally) {
                section_ndx++;
                start_repeat = step_remainder;  // Store this digit; it'll be used to determine when/if the complement begins.
            }
            // Append the current digit to the decimal expansion.  Perform base conversion if not in base 10.
            section_list[section_ndx] += step_digit;
            // This is where you find the remainder in the current step of the division.
            // Example:  for 1/4, the first step would entail multiplying the 1 by 10 and determining how many times 4 divides the result.  Since 4 goes into 10 twice,
            //           the "step_digit" value is 2.  Since 10 - 8 is 2, the "step_remainder" value is 2.
            step_remainder = step_remainder * base - step_digit * reduced_denom;
            // Here's where we detect the repeating portion's complement.  
            // If in the course of calculating the decimal expansion one encounters two remainders whose sum is the denominator, 
            // then repeating portion can be split into two halves, and the sum of the two halves will be one less than an integer power of the number base.
            if (step_remainder + start_repeat == reduced_denom) {
                section_ndx++;
            }
            decimal_length++;
        }
        // ----- END LONG DIVISION -----

        // If the fraction evaluates to a repeating decimal, calculate the number of digits that repeat; otherwise, set it to 'None'.
        repeating = repeating_decimal_flag ? decimal_length - non_repeating_tally : 0;

//        palindromic = section_list.join('').isPalindrome() ? 'Yes' : '';

        return { "decimal_length" : decimal_length,
                     "repeating" : repeating,
                     "decimal_parts" : section_list,
                     "palindromic" : palindromic
                };
    }


    function count_non_repeating() {
        var base_factor_tally = 0;
        var base_tmp = base;
        var denom_tmp = reduced_denom;
        var max_non_repeat_tally = 0;
        var non_repeat_tally = 0;
        var prime_ndx = 1;
        var retval = 0;

        // Loop through the prime number list, starting with 2 and continuing through the largest prime factor of the number base.
        while (primes[prime_ndx] <= base_tmp) {
            // non_repeat_tally must be initialized to 0 for each prime number in the cycle, so that the maximum tally can be determined.
            non_repeat_tally = 0;
            base_factor_tally = 0;
            // First, tally the occurrences of the present prime number in the base's set of factors.
            while (base_tmp / primes[prime_ndx] == Math.floor(base_tmp / primes[prime_ndx])) {
                base_tmp /= primes[prime_ndx];
                base_factor_tally++;
            }      
            // If the present prime is indeed a factor of the base, process this block.
            if (base_factor_tally > 0) {
                // This block will determine the number of non-repeating decimal places generated for the current prime number.  The maximum value from this will be returned.
                prime_power = Math.pow(primes[prime_ndx], base_factor_tally);
                // First, divide out all complete sets of the present prime number from the denominator, and tally the number of divisions.
                while (denom_tmp / prime_power == Math.floor(denom_tmp / prime_power)) {
                    denom_tmp /= prime_power;
                    non_repeat_tally++;
                }
                // Second, check for any remaining instances of the prime number.  If there are any, increment the tally, and divide out all that remain.
                if (denom_tmp / primes[prime_ndx] == Math.floor(denom_tmp / primes[prime_ndx])) {
                    non_repeat_tally++;
                    while (denom_tmp / primes[prime_ndx] == Math.floor(denom_tmp / primes[prime_ndx])) {
                        denom_tmp /= primes[prime_ndx];
                    }
                }
                // Keep the max_non_repeat_tally up-to-date.
                max_non_repeat_tally = Math.max(non_repeat_tally, max_non_repeat_tally);
            }
            prime_ndx++;
        }
        // If denom_tmp is equal to 1 at this point, the denominator's prime factors are all included in the set of factors for the base, which means the decimal resolves.
        // If the denominator has no factors in common with the base, then there are no non-repeating digits.
        retval = denom_tmp == 1 ? -1 : max_non_repeat_tally;
        return retval;
    }


    function get_gcf(int1, int2) {
        var ints = [int1, int2];

        var finished = false;
        while (!finished) {
            ints = [Math.max(ints[0], ints[1]), Math.min(ints[0], ints[1])];
            if (ints[0] / ints[1] == Math.floor(ints[0] / ints[1])) {
                finished = true;
            } else {
                ints[0] = ints[0] - ints[1];
            }
        }
        return ints[1];
    }


}


exports.decimals = Decimals;

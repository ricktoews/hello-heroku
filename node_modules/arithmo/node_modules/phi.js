var pascal = require("pascal");

var _pascal = pascal.pascal;

function phiPowers(power) {
	if (!power) power = 10;

	var data = {};
	var maxrows = pascal.pascal.length - 1;
	power = Math.min(power, maxrows);
	for (var p = 1; p <= power; p++) {
		data[p] = _get_phi_power(p);
	}

	return {
		data: data,
	};
}


function phiXY(pair) {
	var data = [pair];
	for (var i = 1; i <= 10; i++) {
    	pair = next_pair(pair);
    	data.push(pair);
	}
	return data;
}

function next_pair(pair) {
    return { x: (pair.x + pair.y*5) / 2, y: (pair.x + pair.y) / 2 };
}

function make_term(p, n) {
	var term,
	    type;

	// sqrt(5) raised to an even power (i) yields the integer 5^(i/2).
	if (n % 2 == 0) {
		term = _pascal[p][p - n] * Math.pow(5, n / 2);
		type = "whole";
	}
	// sqrt(5) raised to an odd power yields an integer * sqrt(5).
	//    That integer is naturally 5^((i-1)/2).
	else {
		term = _pascal[p][p - n] * Math.pow(5, (n - 1) / 2);
		type = "root";
	}

	var data = {
		term: term,
		type: type
	};
	return data;
}


function get_totals(p) {
	var whole = 0,
		root = 0;

	for (var i = p; i >= 0; i--) {
		var termObj = make_term(p, i);
		if (termObj.type == "whole")
			whole += termObj.term;
		else
			root += termObj.term;
	}

	return {
		whole: whole,
		root: root
	};
}


function _get_phi_power(p) {
	var whole,
		root,
		denominator = 2,
		cancel = Math.pow(2, p - 1),
	    real_value = Math.pow((Math.pow(5, .5) + 1)/2, p),
	    fib_approx = real_value / Math.pow(5, .5),
	    intermediate = get_totals(p);

	// at this point, we have two sums:  the whole number part, and the
	// "coefficient" for sqrt(5).  Since the denominator is going to be 2,
	// we must cancel out the appropriate power of 2 from the numerator.
	whole = intermediate.whole / cancel;
	root = intermediate.root / cancel;

	return {
		power: p,
		real_value: real_value,
		sqrt_5_coef: root,
		whole: whole,
		denom: denominator,
		fib_approx: fib_approx,
	};
}

exports.phiPowers = phiPowers;
exports.phiXY = phiXY;